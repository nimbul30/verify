<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="data:," />
    <link rel="icon" href="data:," />
    <title>AI-Assisted Verification Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
      .spinner {
        border-top-color: #3498db;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .report-section {
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 1rem;
        margin-bottom: 1rem;
      }
      .report-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-8">
      <header class="text-center mb-8">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-900">
          AI-Assisted Verification Tool
        </h1>
        <p class="text-md text-gray-600 mt-2">
          Automate the preliminary checks of your AI-generated content.
        </p>
      </header>

      <main class="bg-white rounded-lg shadow-md p-6 max-w-4xl mx-auto">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Input Column -->
          <div>
            <h2 class="text-xl font-semibold mb-3">1. Paste Your Content</h2>
            <div>
              <label
                for="article-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Article Text</label
              >
              <textarea
                id="article-input"
                rows="12"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="Paste the full text of the article you want to verify here..."
              ></textarea>
            </div>
            <div class="mt-4">
              <label
                for="sources-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Source URLs (one per line)</label
              >
              <textarea
                id="sources-input"
                rows="6"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="https://www.example.com/source1&#10;https://www.anothersource.com/data"
              ></textarea>
            </div>
          </div>

          <!-- Control & API Key Column -->
          <div>
            <h2 class="text-xl font-semibold mb-3">
              2. Get Verification Report
            </h2>
            <div class="mb-4">
              <label
                for="api-key-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Your Gemini API Key</label
              >
              <input
                type="password"
                id="api-key-input"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="Paste your API key here"
              />
            </div>
            <div class="flex space-x-2">
              <button
                id="verify-button"
                class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out"
              >
                Verify Article
              </button>
              <button
                id="markup-button"
                class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-150 ease-in-out"
              >
                Markup Only
              </button>
              <button
                id="parse-button"
                class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition duration-150 ease-in-out"
              >
                Parse
              </button>
            </div>

            <div id="status-container" class="mt-4 text-center">
              <div
                id="loader"
                class="hidden spinner w-8 h-8 border-4 rounded-full mx-auto"
              ></div>
              <p id="status-text" class="text-gray-600 font-medium mt-2"></p>
            </div>
          </div>
        </div>
        <!-- Report Output Section -->
        <div
          id="report-output"
          class="hidden mt-6 pt-6 border-t border-gray-200"
        >
          <h2 class="text-2xl font-bold text-gray-900 mb-4 text-center">
            Verification Report
          </h2>
          <div id="report-content" class="bg-gray-50 p-4 rounded-lg">
            <!-- Dynamic report content will be injected here -->
          </div>
        </div>
      </main>
    </div>

    <script>
      const verifyButton = document.getElementById('verify-button');
      const markupButton = document.getElementById('markup-button');
      const parseButton = document.getElementById('parse-button');
      const articleInput = document.getElementById('article-input');
      const sourcesInput = document.getElementById('sources-input');
      const apiKeyInput = document.getElementById('api-key-input');
      const loader = document.getElementById('loader');
      const statusText = document.getElementById('status-text');
      const reportOutput = document.getElementById('report-output');
      const reportContent = document.getElementById('report-content');

      verifyButton.addEventListener('click', async () => {
        const apiKey = apiKeyInput.value.trim();
        const articleText = articleInput.value.trim();
        const sourceUrls = sourcesInput.value
          .trim()
          .split('\n')
          .filter((url) => url);

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (!articleText || sourceUrls.length === 0) {
          alert('Please provide both an article and at least one source URL.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          sourceUrls,
          apiKey
        );
        const report = await assistant.run_full_verification();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Verification Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      markupButton.addEventListener('click', async () => {
        const apiKey = apiKeyInput.value.trim();
        const articleText = articleInput.value.trim();

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (!articleText) {
          alert('Please provide an article to markup.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          [], // No sources needed for markup only
          apiKey
        );
        const report = await assistant.run_markup_only_verification();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      parseButton.addEventListener('click', async () => {
        const articleText = articleInput.value.trim();

        if (!articleText) {
          alert('Please provide an article to parse.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = true;
        parseButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          [], // No sources needed for parsing
          '' // No API key needed for parsing
        );
        const report = await assistant.run_parser_only();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Parsing Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = false;
        parseButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      function renderHtmlReport(report) {
        reportContent.innerHTML = ''; // Clear previous report

        // Phase 1
        const phase1 = report['Phase 1: Triage'];
        if (phase1) {
          let phase1Html = `<div class="report-section">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">Phase 1: Triage</h3>`;

          // Create a map for citation assessments for easy lookup
          const citation_analysis = phase1['Citation Analysis'];
          const assessment_map = new Map();
          if (citation_analysis && citation_analysis.citation_assessments) {
            citation_analysis.citation_assessments.forEach(item => {
              assessment_map.set(item.citation, {assessment: item.assessment, publication_date: item.publication_date});
            });
          }

          // Source Links
          const links = phase1['Source Link Check'];
          if (links && links.length > 0) {
            phase1Html += `<h4 class="text-lg font-semibold mb-2 text-gray-700">Source Link Analysis</h4><ul class="list-disc list-inside space-y-1 text-sm">`;
            links.forEach((link) => {
              if (link.type === 'citation') {
                const assessment_obj = assessment_map.get(link.text);
                const assessment = assessment_obj ? assessment_obj.assessment : '';
                const publication_date = assessment_obj ? assessment_obj.publication_date : '';
                phase1Html += `<li>${link.text} - <span class="font-medium text-gray-600">${assessment || ''}</span> (Published: ${publication_date})</li>`;
              } else {
                const linked_text = link.text.replace(link.url, `<a href="${link.url}" target="_blank" class="text-blue-600 hover:underline">${link.url}</a>`);
                phase1Html += `<li>${linked_text} - <span class="font-medium">${link.domain_type}</span> (Published: ${link.publication_date}, Accessed: ${link.accessed_date})</li>`;
              }
            });
            phase1Html += `</ul>`;
          }

          // Claim Mapping
          const claims = phase1['Claim-to-Source Mapping']?.verification_claims;
          if (claims && claims.length > 0) {
            phase1Html += `<h4 class="text-lg font-semibold mt-4 mb-2 text-gray-700">Claim-to-Source Mapping</h4><ul class="list-decimal list-inside space-y-2 text-sm">`;
            claims.forEach((item) => {
              phase1Html += `<li><strong>Claim:</strong> ${item.claim}<br><strong>Assessment:</strong> ${item.source_evidence_assessment}<br><strong>Source:</strong> ${item.source_citation}</li>`;
            });
            phase1Html += `</ul>`;
          }
          phase1Html += `</div>`;
          reportContent.innerHTML += phase1Html;
        }

        // Article Summary
        const summary = report['Article Summary'];
        if (summary && summary.summary) {
          let summaryHtml = `<div class="report-section">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">Article Summary</h3>
                    <p class="text-sm text-gray-700">${summary.summary}</p>
                  </div>`;
          reportContent.innerHTML += summaryHtml;
        }

        // Markup System
        const markup = report['Markup System'];
        if (markup && markup.marked_up_text) {
          let markupHtml = `<div class="report-section">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">Markup System</h3>
                    <pre class="bg-gray-200 p-3 rounded text-sm whitespace-pre-wrap font-mono">${markup.marked_up_text}</pre>
                  </div>`;
          reportContent.innerHTML += markupHtml;
        }

        // Media Headlines
        const headlines = report['Media Headlines'];
        if (headlines && headlines.headlines && headlines.headlines.length > 0) {
            let headlinesHtml = `<div class="report-section">
                <h3 class="text-xl font-semibold mb-3 text-gray-800">Media Headlines</h3>
                <ol class="list-decimal list-inside space-y-2 text-sm">`;
            headlines.headlines.forEach(headline => {
                headlinesHtml += `<li class="text-gray-700">${headline}</li>`;
            });
            headlinesHtml += `</ol></div>`;
            reportContent.innerHTML += headlinesHtml;
        }

        // Keywords
        const keywords = report['Keywords'];
        if (keywords && keywords.keywords && keywords.keywords.length > 0) {
            let keywordsHtml = `<div class="report-section">
                <h3 class="text-xl font-semibold mb-3 text-gray-800">Keywords</h3>
                <div class="text-sm text-gray-700">
                  <p>${keywords.keywords.join(', ')}</p>
                </div>
              </div>`;
            reportContent.innerHTML += keywordsHtml;
        }

        // Bias Analysis
        const bias = report['Bias Analysis'];
        if (bias && bias.bias_analysis && bias.bias_analysis.length > 0) {
            let biasHtml = `<div class="report-section">
                <h3 class="text-xl font-semibold mb-3 text-gray-800">Bias Analysis</h3>
                <ul class="list-disc list-inside space-y-2 text-sm">`;
            bias.bias_analysis.forEach(item => {
                biasHtml += `<li><strong>Biased Phrase:</strong> ${item.biased_phrase}<br><strong>Explanation:</strong> ${item.explanation}<br><strong>Suggestion:</strong> ${item.suggestion}</li>`;
            });
            biasHtml += `</ul></div>`;
            reportContent.innerHTML += biasHtml;
        }

        // Suggested Reading
        const suggested_reading = report['Suggested Reading'];
        if (suggested_reading && suggested_reading.suggested_reading && suggested_reading.suggested_reading.length > 0) {
            let readingHtml = `<div class="report-section">
                <h3 class="text-xl font-semibold mb-3 text-gray-800">Suggested Reading</h3>
                <ul class="list-disc list-inside space-y-2 text-sm">`;
            suggested_reading.suggested_reading.forEach(item => {
                readingHtml += `<li><strong>${item.title}</strong> by ${item.author}<br>${item.description}</li>`;
            });
            readingHtml += `</ul></div>`;
            reportContent.innerHTML += readingHtml;
        }

        // Parsed Article
        const parsed_article = report['Parsed Article'];
        if (parsed_article && parsed_article.chunks && parsed_article.chunks.length > 0) {
            let parsedHtml = `<div class="report-section">
                <h3 class="text-xl font-semibold mb-3 text-gray-800">Parsed Article</h3>`;
            parsed_article.chunks.forEach((chunk, index) => {
                parsedHtml += `<div class="mb-2">
                    <h4 class="text-lg font-semibold text-gray-700">Chunk ${index + 1}</h4>
                    <p class="text-sm text-gray-600">${chunk}</p>
                </div>`;
            });
            parsedHtml += `</div>`;
            reportContent.innerHTML += parsedHtml;
        }
      }

      async function call_gemini_api(
        apiKey,
        system_prompt,
        user_content,
        schema = null,
        max_retries = 3
      ) {
        console.log(
          `--- Calling Gemini API... (Prompt: ${system_prompt.substring(
            0,
            50
          )}...) ---`
        );
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
        const headers = { 'Content-Type': 'application/json' };
        const payload = {
          systemInstruction: { parts: [{ text: system_prompt }] },
          contents: [{ parts: [{ text: user_content }] }],
        };

        if (schema) {
          payload.generationConfig = {
            responseMimeType: 'application/json',
            responseSchema: schema,
          };
        }

        for (let attempt = 0; attempt < max_retries; attempt++) {
          try {
            const response = await fetch(GEMINI_API_URL, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(payload),
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];
            const text_response = candidate?.content?.parts?.[0]?.text;

            if (!text_response) {
              throw new Error('Invalid response structure from API.');
            }

            return JSON.parse(text_response);
          } catch (e) {
            if (attempt < max_retries - 1) {
              const wait_time = 2 ** attempt;
              console.log(
                `API request failed with error: ${e}. Retrying in ${wait_time} seconds...`
              );
              await new Promise((resolve) =>
                setTimeout(resolve, wait_time * 1000)
              );
            } else {
              console.error(
                `API request failed after ${max_retries} attempts. Error: ${e}`
              );
              statusText.textContent = `Error: API request failed. Check the console for details.`;
              return JSON.parse('{}'); // Return empty JSON on final failure
            }
          }
        }
      }

      class AI_Verification_Assistant {
        constructor(article_text, source_urls, apiKey) {
          this.article_text = article_text;
          this.source_urls = source_urls;
          this.apiKey = apiKey;
          this.verification_report = {};
        }

        async run_full_verification() {
          statusText.textContent = 'Running Phase 1: Triage...';
          await this.phase1_triage();

          statusText.textContent = 'Generating Summary...';
          this.verification_report['Article Summary'] = await this.generate_summary();

          statusText.textContent = 'Generating Markup...';
          this.verification_report['Markup System'] = await this.generate_markup();

          statusText.textContent = 'Generating Headlines...';
          this.verification_report['Media Headlines'] = await this.generate_media_headlines();

          statusText.textContent = 'Generating Keywords...';
          this.verification_report['Keywords'] = await this.generate_keywords();

          statusText.textContent = 'Analyzing for Bias...';
          this.verification_report['Bias Analysis'] = await this.analyze_bias();

          statusText.textContent = 'Generating Suggested Reading...';
          this.verification_report['Suggested Reading'] = await this.generate_suggested_reading();

          return this.verification_report;
        }

        async run_markup_only_verification() {
          statusText.textContent = 'Generating Summary...';
          this.verification_report['Article Summary'] = await this.generate_summary();

          statusText.textContent = 'Generating Markup...';
          this.verification_report['Markup System'] = await this.generate_markup();

          statusText.textContent = 'Generating Headlines...';
          this.verification_report['Media Headlines'] = await this.generate_media_headlines();

          statusText.textContent = 'Generating Keywords...';
          this.verification_report['Keywords'] = await this.generate_keywords();

          statusText.textContent = 'Analyzing for Bias...';
          this.verification_report['Bias Analysis'] = await this.analyze_bias();

          statusText.textContent = 'Generating Suggested Reading...';
          this.verification_report['Suggested Reading'] = await this.generate_suggested_reading();

          return this.verification_report;
        }

        async run_parser_only() {
          statusText.textContent = 'Parsing Article...';
          this.verification_report['Parsed Article'] = this.parse_article();
          return this.verification_report;
        }

        async phase1_triage() {
          const source_check_results = await this._check_source_links();
          const citations = source_check_results
            .filter((source) => source.type === 'citation')
            .map((source) => source.text);

          let citation_analysis = null;
          if (citations.length > 0) {
            citation_analysis = await this._analyze_citations(citations);
          }

          const claim_mapping = await this._map_claims_to_sources();
          this.verification_report['Phase 1: Triage'] = {
            'Source Link Check': source_check_results,
            'Citation Analysis': citation_analysis,
            'Claim-to-Source Mapping': claim_mapping,
          };
        }

        async _check_source_links() {
          const url_regex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
          const source_details_promises = this.source_urls.map(async (source) => {
            const url_match = source.match(url_regex);
            if (url_match) {
              const url = url_match[0];
              const details = await this._get_source_details(url);
              return {
                type: 'url',
                text: source,
                url: url,
                status: 'Domain Analyzed',
                domain_type: details.source_type,
                publication_date: details.publication_date,
                accessed_date: new Date().toISOString().split('T')[0]
              };
            } else {
              return { type: 'citation', text: source };
            }
          });
          return Promise.all(source_details_promises);
        }

        async _get_source_details(url) {
          const system_prompt = `
            You are a source analysis expert. For the given URL, identify the type of source (e.g., newspaper, online news corp., blog, research journal, etc.) and the publication date.
          `;
          const user_content = `URL: ${url}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              source_type: {
                type: 'STRING',
                description: 'The type of the source.'
              },
              publication_date: {
                type: 'STRING',
                description: 'The publication date of the source (YYYY-MM-DD).'
              }
            },
            required: ['source_type', 'publication_date']
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async _analyze_citations(citations) {
          const system_prompt =
            'You are a source analysis expert. For each of the following citations, provide a brief assessment of its likely reputation and relevance. For example, is it a reputable academic journal, a mainstream news source, a partisan blog, etc.? Also provide the publication date if available.';
          const user_content = `CITATIONS:\n${citations.join('\n')}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              citation_assessments: {
                type: 'ARRAY',
                items: {
                  type: 'OBJECT',
                  properties: {
                    citation: { type: 'STRING' },
                    assessment: { type: 'STRING' },
                    publication_date: { type: 'STRING' },
                  },
                  required: ['citation', 'assessment', 'publication_date'],
                },
              },
            },
          };
          return call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
        }

        async _map_claims_to_sources() {
          const today = new Date().toISOString().split('T')[0];
          const system_prompt =
            `You are a verification expert. Today's date is ${today}. Analyze the user-provided article. Create a list of the key claims from the article. Based on the source URLs provided and your own knowledge, assess if these claims are plausible and likely to be supported. For each claim, provide a detailed explanation of why it is plausible or not, and cite the specific source (URL or text) that supports your assessment.`;
          const user_content = `ARTICLE:\n${
            this.article_text
          }\n\nSOURCE URLs:\n${this.source_urls.join('\n')}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              verification_claims: {
                type: 'ARRAY',
                items: {
                  type: 'OBJECT',
                  properties: {
                    claim: { type: 'STRING' },
                    source_evidence_assessment: { type: 'STRING' },
                    source_citation: { type: 'STRING' },
                  },
                  required: ['claim', 'source_evidence_assessment', 'source_citation'],
                },
              },
            },
          };
          return call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
        }

        async generate_summary() {
          const system_prompt = `
            You are a content analyst. Your task is to draft a very small paragraph of the key-points of the article that helps the reader understand the context of the article.
          `;
          const user_content = `ARTICLE TO SUMMARIZE:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              summary: {
                type: 'STRING',
                description: 'A short summary of the article.'
              }
            },
            required: ['summary']
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }


        async generate_markup() {
          const system_prompt = `
            You are a markup expert. Your task is to apply markdown formatting to the provided article text.
            Your main goal is to make the article easy to read.
            Follow these rules:
            - Replace every single space with a double space.
            - Create more paragraphs by using double line breaks to space out the text.
            - Use italics (*) for emphasis where appropriate to make key points stand out.
            - Use standard markdown for other elements like headers (#), bold (**), lists (- or 1.), and quotes (>).
            The user needs the raw markdown text with all characters like #, *, etc., visible. Do not render the markdown.
          `;
          const user_content = `ARTICLE TO MARKUP:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              marked_up_text: {
                type: 'STRING',
                description: 'The article text with markdown formatting applied.'
              }
            },
            required: ['marked_up_text']
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async generate_media_headlines() {
            const system_prompt = `
                You are a senior editor at a major news publication. Your task is to generate 10
                compelling, media-friendly headlines for the provided news article. The headlines should be
                punchy, informative, and designed to capture public interest. Ensure they are diverse in
                style, including some that are question-based, some that are direct statements, and
                some that are more evocative.
            `;
            const user_content = `ARTICLE FOR HEADLINES:\n${this.article_text}`;
            const schema = {
                type: 'OBJECT',
                properties: {
                    headlines: {
                        type: 'ARRAY',
                        description: 'A list of 10 distinct, media-friendly headlines.',
                        items: { type: 'STRING' }
                    }
                },
                required: ['headlines']
            };
            const result = await call_gemini_api(
                this.apiKey,
                system_prompt,
                user_content,
                schema
            );
            return result;
        }

        async generate_keywords() {
            const system_prompt = `
                You are a search engine optimization (SEO) expert. Your task is to generate 10-15
                relevant keyword search terms for the provided news article. These keywords should be
                what a user might search for on Google. If a keyword is two words,
                combine them with a hyphen, for example: 'sad-clown'.
            `;
            const user_content = `ARTICLE FOR KEYWORDS:\n${this.article_text}`;
            const schema = {
                type: 'OBJECT',
                properties: {
                    keywords: {
                        type: 'ARRAY',
                        description: 'A list of 10-15 distinct keyword search terms.',
                        items: { type: 'STRING' }
                    }
                },
                required: ['keywords']
            };
            const result = await call_gemini_api(
                this.apiKey,
                system_prompt,
                user_content,
                schema
            );
            return result;
        }

        async analyze_bias() {
            const system_prompt = `
                You are a language and bias expert. Review the article for neutral language and absence of bias.
                Provide a detailed analysis of any biased language or framing you find.
                For each issue, provide a suggestion for how to improve it to be more neutral.
            `;
            const user_content = `ARTICLE TO ANALYZE:\n${this.article_text}`;
            const schema = {
                type: 'OBJECT',
                properties: {
                    bias_analysis: {
                        type: 'ARRAY',
                        items: {
                            type: 'OBJECT',
                            properties: {
                                biased_phrase: { type: 'STRING' },
                                explanation: { type: 'STRING' },
                                suggestion: { type: 'STRING' },
                            },
                            required: ['biased_phrase', 'explanation', 'suggestion'],
                        },
                    },
                },
            };
            const result = await call_gemini_api(
                this.apiKey,
                system_prompt,
                user_content,
                schema
            );
            return result;
        }

        async generate_suggested_reading() {
            const system_prompt = `
                You are a research assistant. Based on the provided article, generate a list of 3-5 suggested readings (books, articles, etc.) on the same subject matter.
                For each suggestion, provide the title, author, and a brief description.
            `;
            const user_content = `ARTICLE:\n${this.article_text}`;
            const schema = {
                type: 'OBJECT',
                properties: {
                    suggested_reading: {
                        type: 'ARRAY',
                        items: {
                            type: 'OBJECT',
                            properties: {
                                title: { type: 'STRING' },
                                author: { type: 'STRING' },
                                description: { type: 'STRING' },
                            },
                            required: ['title', 'author', 'description'],
                        },
                    },
                },
            };
            const result = await call_gemini_api(
                this.apiKey,
                system_prompt,
                user_content,
                schema
            );
            return result;
        }

        parse_article() {
            const chunks = [];
            let remaining_text = this.article_text;
            while (remaining_text.length > 0) {
                if (remaining_text.length <= 450) {
                    chunks.push(remaining_text);
                    break;
                }
                let chunk = remaining_text.substring(0, 450);
                let last_space = chunk.lastIndexOf(' ');
                if (last_space !== -1) {
                    chunk = chunk.substring(0, last_space);
                }
                chunks.push(chunk);
                remaining_text = remaining_text.substring(chunk.length + 1);
            }
            return { chunks: chunks };
        }
      }
    </script>
  </body>
</html>
