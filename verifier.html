<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="data:," />
    <link rel="icon" href="data:," />
    <title>AI-Assisted Verification Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
      .spinner {
        border-top-color: #3498db;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .report-section {
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 1rem;
        margin-bottom: 1rem;
      }
      .report-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-8">
      <header class="text-center mb-8">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-900">
          AI-Assisted Verification Tool
        </h1>
        <p class="text-md text-gray-600 mt-2">
          Automate the preliminary checks of your AI-generated content.
        </p>
      </header>

      <main class="bg-white rounded-lg shadow-md p-6 max-w-4xl mx-auto">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Input Column -->
          <div>
            <h2 class="text-xl font-semibold mb-3">1. Paste Your Content</h2>
            <div>
              <label
                for="article-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Article Text</label
              >
              <textarea
                id="article-input"
                rows="12"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="Paste the full text of the article you want to verify here..."
              ></textarea>
            </div>
            <div class="mt-4">
              <label
                for="sources-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Source URLs (one per line)</label
              >
              <textarea
                id="sources-input"
                rows="6"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="https://www.example.com/source1&#10;https://www.anothersource.com/data"
              ></textarea>
            </div>
          </div>

          <!-- Control & API Key Column -->
          <div>
            <h2 class="text-xl font-semibold mb-3">
              2. Get Verification Report
            </h2>
            <div class="mb-4">
              <label
                for="api-key-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Your Gemini API Key</label
              >
              <input
                type="password"
                id="api-key-input"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="Paste your API key here"
              />
            </div>
            <div class="flex space-x-2">
              <button
                id="verify-button"
                class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out"
              >
                Verify Article
              </button>
              <button
                id="markup-button"
                class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-150 ease-in-out"
              >
                Markup Only
              </button>
            </div>

            <div id="status-container" class="mt-4 text-center">
              <div
                id="loader"
                class="hidden spinner w-8 h-8 border-4 rounded-full mx-auto"
              ></div>
              <p id="status-text" class="text-gray-600 font-medium mt-2"></p>
            </div>
          </div>
        </div>
        <!-- Report Output Section -->
        <div
          id="report-output"
          class="hidden mt-6 pt-6 border-t border-gray-200"
        >
          <h2 class="text-2xl font-bold text-gray-900 mb-4 text-center">
            Verification Report
          </h2>
          <div id="report-content" class="bg-gray-50 p-4 rounded-lg">
            <!-- Dynamic report content will be injected here -->
          </div>
        </div>
      </main>
    </div>

    <script>
      const verifyButton = document.getElementById('verify-button');
      const markupButton = document.getElementById('markup-button');
      const articleInput = document.getElementById('article-input');
      const sourcesInput = document.getElementById('sources-input');
      const apiKeyInput = document.getElementById('api-key-input');
      const loader = document.getElementById('loader');
      const statusText = document.getElementById('status-text');
      const reportOutput = document.getElementById('report-output');
      const reportContent = document.getElementById('report-content');

      verifyButton.addEventListener('click', async () => {
        const apiKey = apiKeyInput.value.trim();
        const articleText = articleInput.value.trim();
        const sourceUrls = sourcesInput.value
          .trim()
          .split('\n')
          .filter((url) => url);

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (!articleText || sourceUrls.length === 0) {
          alert('Please provide both an article and at least one source URL.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          sourceUrls,
          apiKey
        );
        const report = await assistant.run_full_verification();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Verification Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      markupButton.addEventListener('click', async () => {
        const apiKey = apiKeyInput.value.trim();
        const articleText = articleInput.value.trim();

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (!articleText) {
          alert('Please provide an article to markup.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          [], // No sources needed for markup only
          apiKey
        );
        const report = await assistant.run_markup_only_verification();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Markup Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      function renderHtmlReport(report) {
        reportContent.innerHTML = ''; // Clear previous report

        // Phase 1
        const phase1 = report['Phase 1: Triage'];
        if (phase1) {
          let phase1Html = `<div class="report-section">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">Phase 1: Triage</h3>`;

          // Create a map for citation assessments for easy lookup
          const citation_analysis = phase1['Citation Analysis'];
          const assessment_map = new Map();
          if (citation_analysis && citation_analysis.citation_assessments) {
            citation_analysis.citation_assessments.forEach(item => {
              assessment_map.set(item.citation, item.assessment);
            });
          }

          // Source Links
          const links = phase1['Source Link Check'];
          if (links && links.length > 0) {
            phase1Html += `<h4 class="text-lg font-semibold mb-2 text-gray-700">Source Link Analysis</h4><ul class="list-disc list-inside space-y-1 text-sm">`;
            links.forEach((link) => {
              if (link.type === 'citation') {
                const assessment = assessment_map.get(link.text);
                phase1Html += `<li>${link.text} - <span class="font-medium text-gray-600">${assessment || ''}</span></li>`;
              } else {
                const linked_text = link.text.replace(link.url, `<a href="${link.url}" target="_blank" class="text-blue-600 hover:underline">${link.url}</a>`);
                phase1Html += `<li>${linked_text} - <span class="font-medium">${link.domain_type}</span></li>`;
              }
            });
            phase1Html += `</ul>`;
          }

          // Claim Mapping
          const claims = phase1['Claim-to-Source Mapping']?.verification_claims;
          if (claims && claims.length > 0) {
            phase1Html += `<h4 class="text-lg font-semibold mt-4 mb-2 text-gray-700">Claim-to-Source Mapping</h4><ul class="list-decimal list-inside space-y-2 text-sm">`;
            claims.forEach((item) => {
              phase1Html += `<li><strong>Claim:</strong> ${item.claim}<br><strong>Assessment:</strong> ${item.source_evidence_assessment}</li>`;
            });
            phase1Html += `</ul>`;
          }
          phase1Html += `</div>`;
          reportContent.innerHTML += phase1Html;
        }

        // Markup System
        const markup = report['Markup System'];
        if (markup && markup.marked_up_text) {
          let markupHtml = `<div class="report-section">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">Markup System</h3>
                    <pre class="bg-gray-200 p-3 rounded text-sm whitespace-pre-wrap font-mono">${markup.marked_up_text}</pre>
                  </div>`;
          reportContent.innerHTML += markupHtml;
        }

        // Media Headlines
        const headlines = report['Media Headlines'];
        if (headlines && headlines.headlines && headlines.headlines.length > 0) {
            let headlinesHtml = `<div class="report-section">
                <h3 class="text-xl font-semibold mb-3 text-gray-800">Media Headlines</h3>
                <ol class="list-decimal list-inside space-y-2 text-sm">`;
            headlines.headlines.forEach(headline => {
                headlinesHtml += `<li class="text-gray-700">${headline}</li>`;
            });
            headlinesHtml += `</ol></div>`;
            reportContent.innerHTML += headlinesHtml;
        }
      }

      async function call_gemini_api(
        apiKey,
        system_prompt,
        user_content,
        schema = null,
        max_retries = 3
      ) {
        console.log(
          `--- Calling Gemini API... (Prompt: ${system_prompt.substring(
            0,
            50
          )}...) ---`
        );
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
        const headers = { 'Content-Type': 'application/json' };
        const payload = {
          systemInstruction: { parts: [{ text: system_prompt }] },
          contents: [{ parts: [{ text: user_content }] }],
        };

        if (schema) {
          payload.generationConfig = {
            responseMimeType: 'application/json',
            responseSchema: schema,
          };
        }

        for (let attempt = 0; attempt < max_retries; attempt++) {
          try {
            const response = await fetch(GEMINI_API_URL, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(payload),
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];
            const text_response = candidate?.content?.parts?.[0]?.text;

            if (!text_response) {
              throw new Error('Invalid response structure from API.');
            }

            return JSON.parse(text_response);
          } catch (e) {
            if (attempt < max_retries - 1) {
              const wait_time = 2 ** attempt;
              console.log(
                `API request failed with error: ${e}. Retrying in ${wait_time} seconds...`
              );
              await new Promise((resolve) =>
                setTimeout(resolve, wait_time * 1000)
              );
            } else {
              console.error(
                `API request failed after ${max_retries} attempts. Error: ${e}`
              );
              statusText.textContent = `Error: API request failed. Check the console for details.`;
              return JSON.parse('{}'); // Return empty JSON on final failure
            }
          }
        }
      }

      class AI_Verification_Assistant {
        constructor(article_text, source_urls, apiKey) {
          this.article_text = article_text;
          this.source_urls = source_urls;
          this.apiKey = apiKey;
          this.verification_report = {};
        }

        async run_full_verification() {
          statusText.textContent = 'Running Phase 1: Triage...';
          await this.phase1_triage();

          statusText.textContent = 'Generating Markup...';
          this.verification_report['Markup System'] = await this.generate_markup();

          statusText.textContent = 'Generating Headlines...';
          this.verification_report['Media Headlines'] = await this.generate_media_headlines();

          return this.verification_report;
        }

        async run_markup_only_verification() {
          statusText.textContent = 'Generating Markup...';
          this.verification_report['Markup System'] = await this.generate_markup();

          statusText.textContent = 'Generating Headlines...';
          this.verification_report['Media Headlines'] = await this.generate_media_headlines();
          return this.verification_report;
        }

        async phase1_triage() {
          const source_check_results = this._check_source_links();
          const citations = source_check_results
            .filter((source) => source.type === 'citation')
            .map((source) => source.text);

          let citation_analysis = null;
          if (citations.length > 0) {
            citation_analysis = await this._analyze_citations(citations);
          }

          const claim_mapping = await this._map_claims_to_sources();
          this.verification_report['Phase 1: Triage'] = {
            'Source Link Check': source_check_results,
            'Citation Analysis': citation_analysis,
            'Claim-to-Source Mapping': claim_mapping,
          };
        }

        _check_source_links() {
          const url_regex = /https?:\/\/[^\s/$.?#].[^\s]*/i;
          return this.source_urls.map((source) => {
            const url_match = source.match(url_regex);
            if (url_match) {
              try {
                const parsed_url = new URL(url_match[0]);
                const domain = parsed_url.hostname;
                const tld = domain.split('.').pop();
                let domain_type = 'General/Blog';

                if (['gov', 'edu'].includes(tld)) {
                  domain_type = 'High-Reputation (Government/Education)';
                } else if (
                  ['reuters.com', 'apnews.com', 'bbc.com', 'wsj.com'].some((d) =>
                    domain.includes(d)
                  )
                ) {
                  domain_type = 'Reputable News Source';
                }
                return {
                  type: 'url',
                  text: source,
                  url: url_match[0],
                  status: 'Domain Analyzed (Live Check N/A)',
                  domain_type,
                };
              } catch (e) {
                // Should not happen if regex is correct, but as a fallback
                return { type: 'citation', text: source };
              }
            } else {
              return { type: 'citation', text: source };
            }
          });
        }

        async _analyze_citations(citations) {
          const system_prompt =
            'You are a source analysis expert. For each of the following citations, provide a brief assessment of its likely reputation and relevance. For example, is it a reputable academic journal, a mainstream news source, a partisan blog, etc.?';
          const user_content = `CITATIONS:\n${citations.join('\n')}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              citation_assessments: {
                type: 'ARRAY',
                items: {
                  type: 'OBJECT',
                  properties: {
                    citation: { type: 'STRING' },
                    assessment: { type: 'STRING' },
                  },
                  required: ['citation', 'assessment'],
                },
              },
            },
          };
          return call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
        }

        async _map_claims_to_sources() {
          const today = new Date().toISOString().split('T')[0];
          const system_prompt =
            `You are a verification expert. Today's date is ${today}. Analyze the user-provided article. Create a list of the key claims from the article. Based on the source URLs provided and your own knowledge, assess if these claims are plausible and likely to be supported. State this assessment clearly. Do not make speculative statements about future dates.`;
          const user_content = `ARTICLE:\n${
            this.article_text
          }\n\nSOURCE URLs:\n${this.source_urls.join('\n')}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              verification_claims: {
                type: 'ARRAY',
                items: {
                  type: 'OBJECT',
                  properties: {
                    claim: { type: 'STRING' },
                    source_evidence_assessment: { type: 'STRING' },
                  },
                  required: ['claim', 'source_evidence_assessment'],
                },
              },
            },
          };
          return call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
        }

        async generate_markup() {
          const system_prompt = `
            You are a markup expert. Your task is to apply markdown formatting to the provided article text.
            Your main goal is to make the article easy to read.
            Follow these rules:
            - Create more paragraphs by using double line breaks to space out the text.
            - Use italics (*) for emphasis where appropriate to make key points stand out.
            - Use standard markdown for other elements like headers (#), bold (**), lists (- or 1.), and quotes (>).
            The user needs the raw markdown text with all characters like #, *, etc., visible. Do not render the markdown.
          `;
          const user_content = `ARTICLE TO MARKUP:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              marked_up_text: {
                type: 'STRING',
                description: 'The article text with markdown formatting applied.'
              }
            },
            required: ['marked_up_text']
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async generate_media_headlines() {
            const system_prompt = `
                You are a senior editor at a major news publication. Your task is to generate 10
                compelling, media-friendly headlines for the provided news article. The headlines should be
                punchy, informative, and designed to capture public interest. Ensure they are diverse in
                style, including some that are question-based, some that are direct statements, and
                some that are more evocative.
            `;
            const user_content = `ARTICLE FOR HEADLINES:\n${this.article_text}`;
            const schema = {
                type: 'OBJECT',
                properties: {
                    headlines: {
                        type: 'ARRAY',
                        description: 'A list of 10 distinct, media-friendly headlines.',
                        items: { type: 'STRING' }
                    }
                },
                required: ['headlines']
            };
            const result = await call_gemini_api(
                this.apiKey,
                system_prompt,
                user_content,
                schema
            );
            return result;
        }
      }
    </script>
  </body>
</html>
